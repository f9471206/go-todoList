// Code generated by MockGen. DO NOT EDIT.
// Source: repositories/interfaces/todo_type_repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	models "todolist/models"
	base "todolist/repositories/base"

	gomock "github.com/golang/mock/gomock"
	gorm "gorm.io/gorm"
)

// MockTodoTypeRepository is a mock of TodoTypeRepository interface.
type MockTodoTypeRepository struct {
	ctrl     *gomock.Controller
	recorder *MockTodoTypeRepositoryMockRecorder
}

// MockTodoTypeRepositoryMockRecorder is the mock recorder for MockTodoTypeRepository.
type MockTodoTypeRepositoryMockRecorder struct {
	mock *MockTodoTypeRepository
}

// NewMockTodoTypeRepository creates a new mock instance.
func NewMockTodoTypeRepository(ctrl *gomock.Controller) *MockTodoTypeRepository {
	mock := &MockTodoTypeRepository{ctrl: ctrl}
	mock.recorder = &MockTodoTypeRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTodoTypeRepository) EXPECT() *MockTodoTypeRepositoryMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockTodoTypeRepository) Create(ctx context.Context, db *gorm.DB, entity *models.TodoTypes) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, db, entity)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockTodoTypeRepositoryMockRecorder) Create(ctx, db, entity interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockTodoTypeRepository)(nil).Create), ctx, db, entity)
}

// FindAllWithQuery mocks base method.
func (m *MockTodoTypeRepository) FindAllWithQuery(ctx context.Context, db *gorm.DB, page, pageSize int, orderBy ...string) ([]*models.TodoTypes, int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, db, page, pageSize}
	for _, a := range orderBy {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindAllWithQuery", varargs...)
	ret0, _ := ret[0].([]*models.TodoTypes)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FindAllWithQuery indicates an expected call of FindAllWithQuery.
func (mr *MockTodoTypeRepositoryMockRecorder) FindAllWithQuery(ctx, db, page, pageSize interface{}, orderBy ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, db, page, pageSize}, orderBy...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAllWithQuery", reflect.TypeOf((*MockTodoTypeRepository)(nil).FindAllWithQuery), varargs...)
}

// FindByID mocks base method.
func (m *MockTodoTypeRepository) FindByID(ctx context.Context, db *gorm.DB, id int, opts ...*base.FindOptions) (*models.TodoTypes, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, db, id}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindByID", varargs...)
	ret0, _ := ret[0].(*models.TodoTypes)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByID indicates an expected call of FindByID.
func (mr *MockTodoTypeRepositoryMockRecorder) FindByID(ctx, db, id interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, db, id}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockTodoTypeRepository)(nil).FindByID), varargs...)
}

// IsNameExist mocks base method.
func (m *MockTodoTypeRepository) IsNameExist(ctx context.Context, db *gorm.DB, name string, excludeID int) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsNameExist", ctx, db, name, excludeID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsNameExist indicates an expected call of IsNameExist.
func (mr *MockTodoTypeRepositoryMockRecorder) IsNameExist(ctx, db, name, excludeID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsNameExist", reflect.TypeOf((*MockTodoTypeRepository)(nil).IsNameExist), ctx, db, name, excludeID)
}

// SoftDelete mocks base method.
func (m *MockTodoTypeRepository) SoftDelete(ctx context.Context, db *gorm.DB, entity *models.TodoTypes) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SoftDelete", ctx, db, entity)
	ret0, _ := ret[0].(error)
	return ret0
}

// SoftDelete indicates an expected call of SoftDelete.
func (mr *MockTodoTypeRepositoryMockRecorder) SoftDelete(ctx, db, entity interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDelete", reflect.TypeOf((*MockTodoTypeRepository)(nil).SoftDelete), ctx, db, entity)
}

// Update mocks base method.
func (m *MockTodoTypeRepository) Update(ctx context.Context, db *gorm.DB, entity *models.TodoTypes) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, db, entity)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockTodoTypeRepositoryMockRecorder) Update(ctx, db, entity interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockTodoTypeRepository)(nil).Update), ctx, db, entity)
}
