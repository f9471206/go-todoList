// Code generated by MockGen. DO NOT EDIT.
// Source: repositories/interfaces/todo_list_repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	models "todolist/models"
	base "todolist/repositories/base"

	gomock "github.com/golang/mock/gomock"
	gorm "gorm.io/gorm"
)

// MockTodoListRepository is a mock of TodoListRepository interface.
type MockTodoListRepository struct {
	ctrl     *gomock.Controller
	recorder *MockTodoListRepositoryMockRecorder
}

// MockTodoListRepositoryMockRecorder is the mock recorder for MockTodoListRepository.
type MockTodoListRepositoryMockRecorder struct {
	mock *MockTodoListRepository
}

// NewMockTodoListRepository creates a new mock instance.
func NewMockTodoListRepository(ctrl *gomock.Controller) *MockTodoListRepository {
	mock := &MockTodoListRepository{ctrl: ctrl}
	mock.recorder = &MockTodoListRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTodoListRepository) EXPECT() *MockTodoListRepositoryMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockTodoListRepository) Create(ctx context.Context, db *gorm.DB, entity *models.TodoList) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, db, entity)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockTodoListRepositoryMockRecorder) Create(ctx, db, entity interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockTodoListRepository)(nil).Create), ctx, db, entity)
}

// FindAllWithQuery mocks base method.
func (m *MockTodoListRepository) FindAllWithQuery(ctx context.Context, db *gorm.DB, page, pageSize int, orderBy ...string) ([]*models.TodoList, int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, db, page, pageSize}
	for _, a := range orderBy {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindAllWithQuery", varargs...)
	ret0, _ := ret[0].([]*models.TodoList)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FindAllWithQuery indicates an expected call of FindAllWithQuery.
func (mr *MockTodoListRepositoryMockRecorder) FindAllWithQuery(ctx, db, page, pageSize interface{}, orderBy ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, db, page, pageSize}, orderBy...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAllWithQuery", reflect.TypeOf((*MockTodoListRepository)(nil).FindAllWithQuery), varargs...)
}

// FindByID mocks base method.
func (m *MockTodoListRepository) FindByID(ctx context.Context, db *gorm.DB, id int, opts ...*base.FindOptions) (*models.TodoList, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, db, id}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindByID", varargs...)
	ret0, _ := ret[0].(*models.TodoList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByID indicates an expected call of FindByID.
func (mr *MockTodoListRepositoryMockRecorder) FindByID(ctx, db, id interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, db, id}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockTodoListRepository)(nil).FindByID), varargs...)
}

// IsNameExist mocks base method.
func (m *MockTodoListRepository) IsNameExist(ctx context.Context, db *gorm.DB, name string, excludeID int) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsNameExist", ctx, db, name, excludeID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsNameExist indicates an expected call of IsNameExist.
func (mr *MockTodoListRepositoryMockRecorder) IsNameExist(ctx, db, name, excludeID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsNameExist", reflect.TypeOf((*MockTodoListRepository)(nil).IsNameExist), ctx, db, name, excludeID)
}

// SoftDelete mocks base method.
func (m *MockTodoListRepository) SoftDelete(ctx context.Context, db *gorm.DB, entity *models.TodoList) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SoftDelete", ctx, db, entity)
	ret0, _ := ret[0].(error)
	return ret0
}

// SoftDelete indicates an expected call of SoftDelete.
func (mr *MockTodoListRepositoryMockRecorder) SoftDelete(ctx, db, entity interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDelete", reflect.TypeOf((*MockTodoListRepository)(nil).SoftDelete), ctx, db, entity)
}

// Update mocks base method.
func (m *MockTodoListRepository) Update(ctx context.Context, db *gorm.DB, entity *models.TodoList) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, db, entity)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockTodoListRepositoryMockRecorder) Update(ctx, db, entity interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockTodoListRepository)(nil).Update), ctx, db, entity)
}
